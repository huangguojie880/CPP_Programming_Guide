<h1>不要在构造函数和析构函数中调用虚函数</h1>

<h2>理由</h2>

**其中所调用的函数其实是目前所构造的对象的函数**，而不是可能在派生类中覆盖它的函数。 这可能是最易混淆的。 更糟的是，从构造函数或析构函数中直接或间接调用未被实现的纯虚函数的话，还会导致未定义的行为。

<h2>示例，不好</h2>

    class Base {
    public:
        virtual void f() = 0;   // 未实现
        virtual void g();       // 有 Base 版本的实现
        virtual void h();       // 有 Base 版本的实现
        virtual ~Base();        // 有 Base 版本的实现
    };

    class Derived : public Base {
    public:
        void g() override;   // 提供 Derived 版本的实现
        void h() final;      // 提供 Derived 版本的实现

        Derived()
        {
            // 不好: 试图调用未经实现的虚函数
            f();

            // 不好: 想要调用 derived::g，但并未发生虚函数分派
            g();

            // 好: 明确说明想要调用的就是写明的版本
            Derived::g();

            // ok，不需要进行限定，h 为 final
            h();
        }
    };

注意，调用一个明确限定的函数时，即便函数是 virtual 的，也不会发生虚函数调用。

参见 工厂函数，以了解如何获得调用派生类函数的效果又不会引发未定义行为。

<h2>注解</h2>

**其实在构造函数和析构函数中调用虚函数并不存在固有的错误**。 这种调用的语义是类型安全的。 

然而，**经验表明这种调用很少真正需要**，易于让维护者混淆，而且当被新手使用之后还会成为一种错误来源。