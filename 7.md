<h1>优先使用异常处理错误</h1>

<h2>理由</h2>
不应该让错误可以被忽略，因为这将导致系统或者一次运算进入未定义的（或者预料之外的）状态。 这是错误的一个主要来源。异常有以下优点：

1. 异常会强制调用代码识别并处理错误状态。 未经处理的异常会停止程序执行
2. 异常跳转到调用堆栈中可以处理错误的位置。中间函数可以让异常传播。这些函数不必与其他层协调
3. 引发异常后，异常堆栈展开机制将根据妥善定义的规则销毁范围内的所有对象
4. 异常可以在检测错误的代码与处理错误的代码之间实现明确的分离
5. 异常是处理构造函数失败的唯一途径

<h2>说明</h2>
异常是一个稍有争议的话题，主要是较为权威的谷歌C++规范明确说明其不允许使用异常，而微软的规范、Bjarne Stroustrup的C++核心编程指南是明确推荐使用异常处理错误。笔者在实际的项目开发中，观察到使用异常的代码也并不多。但是，我认为使用异常利大于弊并推荐你使用，尤其是在新项目中。下面是谷歌C++规范给出的不使用异常的理由：

1. 在现有函数中添加 `throw` 语句时，您必须检查所有调用点
2. 异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回
3. 异常安全需要RAII和不同的编码实践
4. 滥用异常会变相鼓励开发者去捕捉不合时宜

谷歌C++规范中反对异常的理由，在我看来并不是异常的劣势，其仅仅是使用异常的注意事项。就像所有新特性都会有的注意事项一样，只不过异常的使用注意事项复杂了一点，但这并不是不使用异常的理由。

<h2>示例</h2>

<h3>异常使用基本准则</h3>

1. 当处理错误的代码与通过一个或多个中间函数调用检测错误的代码分离时，请使用异常
2. 对于每个可能引发或传播异常的函数，请提供三项异常保证之一：强保证、基本保证或无故障保证

3. 通过值引发异常，通过引用捕获异常
4. 不要使用 C++11 中已弃用的异常规范
5. 使用适用的标准库异常类型。 从 `exception` 类层次结构派生自定义的异常类型
6. 不要允许异常从析构函数中逃逸

<h3>异常和性能</h3>

如果未引发异常，则异常机制的性能开销极低。

如果引发异常，则堆栈遍历和展开的开销与函数调用的开销大致相当。 进入 try 块后，需要使用其他数据结构来跟踪调用堆栈，如果引发异常，则还需要使用更多指令来展开堆栈。 但是，在大多数情况下，性能和内存占用的开销并不高。 异常对性能的不利影响可能仅在内存受限的系统上才比较明显。 或者，这种影响在性能关键型循环中（其中的错误可能经常发生，并且处理错误的代码与报告错误的代码之间存在紧密耦合）可能比较明显。

无论在哪种情况下，不进行分析和测量就不可能知道异常的实际开销。 即使在开销很高的极少数情况下，也可将这种开销与设计良好的异常策略所提供的更高正确性、更方便的维护性和其他优势进行权衡。

<h3>三个异常保证</h3>

无故障保证

此保证声明，该函数将不会引发异常或允许异常传播。此时，应将函数声明为 `noexcept` ，以让编译器最大程度的优化函数，如减少执行路径，提高错误退出的效率。如：

`vector` 等STL容器，为了保证接口的健壮性，如果保存元素的 `move` 运算符没有声明为 `noexcept`，则在容器扩张搬移元素时不会使用 `move` 机制，而使用 `copy` 机制，带来性能损失的风险。

如果一个函数不能抛出异常，或者一个程序并没有截获某个函数所抛出的异常并进行处理，那么这个函数可以用新的 `noexcept` 关键字对其进行修饰，表示这个函数不会抛出异常或者抛出的异常不会被截获并处理。例如：

    // 即使可能抛出异常，也可以使用 noexcept
    // 这里不准备处理内存耗尽的异常，简单地将函数声明为noexcept
    std::vector<int> MyComputation(const std::vector<int>& v) noexcept
    {
        std::vector<int> res = v;    // 可能会抛出异常
        // do something
        return res;
    }