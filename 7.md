<h1>优先使用异常处理错误</h1>

<h2>理由</h2>
不应该让错误可以被忽略，因为这将导致系统或者一次运算进入未定义的（或者预料之外的）状态。 这是错误的一个主要来源。异常有以下优点：

1. 异常会强制调用代码识别并处理错误状态。 未经处理的异常会停止程序执行
2. 异常跳转到调用堆栈中可以处理错误的位置。中间函数可以让异常传播。这些函数不必与其他层协调
3. 引发异常后，异常堆栈展开机制将根据妥善定义的规则销毁范围内的所有对象
4. 异常可以在检测错误的代码与处理错误的代码之间实现明确的分离
5. 异常是处理构造函数失败的唯一途径

<h2>说明</h2>
异常是一个稍有争议的话题，主要是较为权威的谷歌C++规范明确说明其不允许使用异常，而微软的规范、Bjarne Stroustrup的C++核心编程指南是明确推荐使用异常处理错误。笔者在实际的项目开发中，观察到使用异常的代码也并不多。但是，我认为使用异常利大于弊并推荐你使用，尤其是在新项目中。下面是谷歌C++规范给出的不使用异常的理由：

1. 在现有函数中添加 `throw` 语句时，您必须检查所有调用点
2. 异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回
3. 异常安全需要RAII和不同的编码实践
4. 滥用异常会变相鼓励开发者去捕捉不合时宜

谷歌C++规范中反对异常的理由，在我看来并不是异常的劣势，其仅仅是使用异常的注意事项。就像所有新特性都会有的注意事项一样，只不过异常的使用注意事项复杂了一点，但这并不是不使用异常的理由。

<h2>示例</h2>

<h3>异常使用基本准则</h3>

1. 当处理错误的代码与通过一个或多个中间函数调用检测错误的代码分离时，请使用异常
2. 对于每个可能引发或传播异常的函数，请提供三项异常保证之一：强保证、基本保证或无故障保证
3. 通过值引发异常，通过引用捕获异常
4. 不要使用 C++11 中已弃用的异常规范
5. 使用适用的标准库异常类型。 从 `exception` 类层次结构派生自定义的异常类型
6. 默认构造函数、析构函数、`swap` 函数，`move` 操作符都不应该抛出异常

<h3>异常和性能</h3>

如果未引发异常，则异常机制的性能开销极低。

如果引发异常，则堆栈遍历和展开的开销与函数调用的开销大致相当。 进入 try 块后，需要使用其他数据结构来跟踪调用堆栈，如果引发异常，则还需要使用更多指令来展开堆栈。 但是，在大多数情况下，性能和内存占用的开销并不高。 异常对性能的不利影响可能仅在内存受限的系统上才比较明显。 或者，这种影响在性能关键型循环中（其中的错误可能经常发生，并且处理错误的代码与报告错误的代码之间存在紧密耦合）可能比较明显。

无论在哪种情况下，不进行分析和测量就不可能知道异常的实际开销。 即使在开销很高的极少数情况下，也可将这种开销与设计良好的异常策略所提供的更高正确性、更方便的维护性和其他优势进行权衡。

<h3>三个异常保证</h3>

无故障保证

此保证声明，该函数将不会引发异常或允许异常传播。此时，应将函数声明为 `noexcept` ，以让编译器最大程度的优化函数，如减少执行路径，提高错误退出的效率。如：

`vector` 等STL容器，为了保证接口的健壮性，如果保存元素的 `move` 运算符没有声明为 `noexcept`，则在容器扩张搬移元素时不会使用 `move` 机制，而使用 `copy` 机制，带来性能损失的风险。

如果一个函数不能抛出异常，或者一个程序并没有截获某个函数所抛出的异常并进行处理，那么这个函数可以用新的 `noexcept` 关键字对其进行修饰，表示这个函数不会抛出异常或者抛出的异常不会被截获并处理。例如：

    // 即使可能抛出异常，也可以使用 noexcept
    // 这里不准备处理内存耗尽的异常，简单地将函数声明为noexcept
    std::vector<int> MyComputation(const std::vector<int>& v) noexcept
    {
        std::vector<int> res = v;    // 可能会抛出异常
        // do something
        return res;
    }

<h3>通过值引发异常并通过常数引用将其捕获</h3>

    MyData md;
    try {
        md = GetNetworkResource();
    } catch (const networkIOException& e) {
        cerr << e.what();
    } catch (const myDataFormatException& e) {
        cerr << e.what();
    }

    MyData GetNetworkResource()
    {
    if (IOSuccess == false)
        throw networkIOException("Unable to connect");
    if (readError)
        throw myDataFormatException("Format error");
    }

 如果 `catch` 语句指定省略号 `(...)` 而非类型，则 `catch` 程序块将处理每种类型的异常。 由于 `catch` 程序块按编程顺序处理来查找匹配类型，所以尽量不要使用省略号处理程序来处理关联的 `try` 程序块。请谨慎使用 `catch(...)`；除非 `catch` 块知道如何处理捕获的特定异常，否则禁止程序继续执行。 `catch(...)` 块一般用于在程序停止执行前记录错误和执行特殊的清理工作。

 <h3>未处理的异常</h3>

 如果无法找到当前异常的匹配处理程序（或省略号 `catch` 处理程序），则调用预定义的 `terminate` 运行时函数。`terminate` 的默认操作是调用 `abort`。 如果你希望 `terminate` 在退出应用程序之前调用程序中的某些其他函数，则用被调用函数的名称作为其单个自变量调用 `set_terminate` 函数。 您可以在程序的任何点调用 `set_terminate`。 `terminate` 例程总是调用指定为 `set_terminate` 的参数的最后一个函数。

    #include <iostream>
    using namespace std;
    void term_func()
    {
        cout << "term_func was called by terminate." << endl;
        exit( -1 );
    }

    int main() {
        try {
            set_terminate( term_func );
            throw "Out of memory!";
        } catch( int ) {
            cout << "Integer exception raised." << endl;
        }
        return 0;
    }