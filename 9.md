<h1>不要只用一个指针来传递数组</h1>

<h2>理由</h2>

(pointer, size) 式的接口是易于出错的。同样，（指向数组的）普通指针还必须依赖某种约定以使被调用方来确定其大小。

当函数参数类型为数组（不是数组的引用）或者指针时，若调用者传入数组，则在参数传递时数组会退化为指针，其数组长度信息会丢失，容易引发越界读写等问题。 如果函数只接收固定长度的数组为参数，可以定义参数类型为数组引用或者std::array。 如果函数接受的是不带长度的指针，那么应该把长度作为另外一个参数也传递进去。

<h2>讨论</h2>

    void copy_n(const T* p, T* q, int n); // 从 [p:p+n) 复制到 [q:q+n)

当由 `q` 所指向的数组少于 `n` 个元素会怎么样？此时我们将覆写一些可能无关的内存。 当由 `p` 所指向的数组少于 `n` 个元素会怎么样？此时我们将读取一些可能无关的内存。 此二者都是未定义的行为，而且可能是非常恶劣的BUG。

替代方案

考虑使用明确的 `span`：

    void copy(span<const T> r, span<T> r2); // 将 r 复制给 r2


示例，不好

    void draw(Shape* p, int n);  // 糟糕的接口；糟糕的代码
    Circle arr[10];
    // ...
    draw(arr, 10);

把 `10` 作为参数 `n` 传递可能是错误的：虽然最常见的约定是假定有 `[0:n)`，但这点并未不是明确的。更糟糕的是，`draw()` 的调用通过编译了：这里有一次从数组到指针的隐式转换（数组退化），然后又进行了从 `Circle` 到 `Shape` 的另一次隐式转换。`draw()` 是不可能安全地迭代这个数组的：它无法知道元素的大小。

替代方案: 使用一个辅助类来确保元素的数量正确，并避免进行危险的隐式转换。例如：

    void draw2(span<Circle>);
    Circle arr[10];
    // ...
    draw2(span<Circle>(arr));  // 推断出元素的数量
    draw2(arr);    // 推断出元素的类型和数组大小

    void draw3(span<Shape>);
    draw3(arr);    // 错误: 无法将 Circle[10] 转换为 span<Shape>

这个 `draw2()` 传递了与 `draw()` 同样数量的信息，但明确指定了它接受的是 `Circle` 的范围。

    constexpr int MAX_LEN = 1024;
    constexpr int SIZE = 10;

    void UseArr(int arr[])
    {
        for (int i = 0; i < MAX_LEN; i++) {
            std::cout << arr[i] << std::endl;
        }
    }

    void Test()
    {
        int arr[SIZE] = {0};
        UseArr(arr);
    }

可以把指针和长度合起来做成一个类型，方便使用。例如：类似下面的简单封装：

    template <typename T>
    class Slice {
    public:
        template <size_t N>
        Slice(T (&arr)[N]) : data(arr), len(N) {}

        template <size_t N>
        Slice(std::array<T, N> arr) : data(arr.data()), len(N) {}

        Slice(T* arr, size_t n) : data(arr), len(n) {}
        ...

    private:
        T* data;
        size_t len;
    };

    void UseArr(Slice<int> arr)
    {
        for (int i = 0; i < arr.size(); i++) {
            std::cout << arr[i] << std::endl;
        }
    }

    constexpr int SIZE = 10;

    void Test()
    { 
        int arr[SIZE] = {0};
        Slice<int> s{arr};
        UseArr(s);
    }

如果项目允许的话，推荐使用成熟的库来做这个事情，例如C++20中的std::span类型。

在不使用这些工具类的情况下，可以把指针和长度作为两个参数传递。

    void UseArr(int arr[], size_t len)
    {
        for (int i = 0; i < len; i++) {
            std::cout << arr[i] << std::endl;
        }
    }

    constexpr int SIZE = 10;

    void Test()
    {
        int arr[SIZE] = {0};
        UseArr(arr, sizeof(arr));
    }