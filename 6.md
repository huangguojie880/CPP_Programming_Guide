<h1>广泛地使用断言记录内部假设和不变式</h1>

<h2>理由</h2>
广泛地使用断言记录模块内部的各种假设，这些假设是必须成立的，否则就说明存在编程错误。当然，要确保断言不会产生任何副作用。

断言的强大怎么高估都不算过分。项目的成败至少部分取决于开发人员在代码中使用断言的有效性。断言一般只会在调试模式下生成代码，因此在发行版本中它们是不存在的。所以尽管进行检查好了。

软件开发是复杂的，变化乃是常事，而在一个变化着的程序什么事情都有可能发生。断言能够验证你现在确信“显然为真”的事情确实为真。对类型系统无法强制实施的，应该使用断言。

<h2>示例</h2>

<h3>不要在断言中写有副作用的表达式</h3>

    assert( ++i < limit );	//糟糕:i识在调试模式下才递增

<h3>考虑定义自己的assert</h3>

标准的assert宏终止程序的方式非常无礼，只是在标准输出设备上发送一条信息。而自己开发的环境可能会提供更强的调试功能，如在日志文件中记录相关信息。

此外，用抛出异常代替断言是不可取的，虽然标准库的`std:logic_error`异常类最初就是为此目的而设计的。使用异常报告编程错误的主要缺点在于，我们并不真地希望这种情况下出现栈展开一我们只不过想在违反条件的那一行启动调试器，并保持该行状态不变而已。

<h3>仅对不应该发生的错误使用断言</h3>

不要用 `assert` 确保 `malloc` 成功执行、窗口成功创建或者线程成功启动。但是，可以用 `assert` 确保API函数的执行符合文档的记载。例如，如果你需要调用一个文档中记载的、应该总是返回正值的AP1函数，但是你怀疑它可能存在错误，那么可以在调用之后加入一个 `assert`。

<h3>使用Expects来表达前条件</h3>

    int area(int height, int width)
    {
        Expects(height > 0 && width > 0);            // 好
        if (height <= 0 || width <= 0) my_error();   // 隐晦的
        // ...
    }

清晰地表明这个条件是一个前条件，并便于工具的利用。

<h3>使用Ensures来表达后条件</h3>

考虑一个著名的安全性 BUG：

    void f()    // 有问题的
    {
        char buffer[MAX];
        // ...
        memset(buffer, 0, sizeof(buffer));
    }

由于没有后条件来说明缓冲区应当被清零，优化器可能会将这个看似多余的 memset() 调用给清除掉：

    void f()    // 有改进
    {
        char buffer[MAX];
        // ...
        memset(buffer, 0, sizeof(buffer));
        Ensures(buffer[0] == 0);
    }